# 智能指针

会自动销毁的指针。

智能指针有四种种

auto_ptr:如果两个指针指向同一个内存空间，那么只有最后复制的那个指针会真正指向这个内存空间。

unique_ptr:如果两个指针指向同一个内存空间，那么只有最后复制的那个指针会真正指向这个内存空间。策略比auto_ptr严格。

shared_ptr:引用增加时，引用计数+1，引用减少时，引用技术-1。当内存空间的引用计数为0时，内存才会被销毁。

shared_ptr使用时有个问题，想要使得shared_ptr可靠的工作，需要保证只有一个地方使用被持有对象的指针构造shared_ptr，后续其他的指向该对象的shared_ptr需要通过该shared_ptr来进行构造，这样才能保证这个对象实例仅仅有一个shared_ptr的控制块来控制其生命周期，从而保证该对象的生命周期管理是正确的不紊乱的。可以通过继承enable_shared_from_this来解决。



weak_ptr:配合share_ptr的一种指针，它引用的内存区域不会导致该内存区域的引用计数增加。就是python里面的弱引用。



# 内存对齐

# 匿名函数

和python里面的匿名函数差不多

如果表达式只有一条返回语句，则会自动推断返回值。如果没有return，则会推断return void。其定义为：

[](int x) {return x % 3 == 0;}

[]用于替代函数名

如果表达式不止一条返回语句，则需要自己手动指定返回类型。

定义为：

[](double x) -> double{int y=x; return x - y; }



# enable_shared_from_this

如果该对象的一个实例被一个std::shared_ptr<T>的智能指针实例对象管理，则通过调用该智能指针可以返回一个新构造的shared_ptr<T>类型的智能指针，该新构造的智能指针和原有的智能指针共同拥有该对象的所有权。

一个类继承**enable_shared_from_this**后调用shared_from_this即可获得自己的一个引用。


# 静态变量
如果是类的静态变量，那么需要在头文件中定义，并在实现文件中初始化。但是如果使用这个变量的地方和初始化这个变量的地方不在同一个文件中，那么就会出现还没有初始化就在开始使用了的问题。会报错。
解决方案就是执行初始化。可以通过懒初始化的方式在处理。
private:
	static ConfigVarMap& getDatas() {
		static ConfigVarMap m_datas;
		return m_datas;
	}
这样在调用这个方法的时候就会对m_datas直接进行定义和初始化（与类中定义静态变量不同，类中定义的静态变量需要单独进行初始化）。也不会出现重复定义的问题。

# 没有比较函数的对象
例如functional库中的function，没有比较函数，所以放到list或者vector中之后，会无法通过find方法去获取，也无法进行排序等操作。
可以放在map中当value，这样需要比较的时候就用key去比较
